---
layout: post
title: "数据结构错题本"
image: ''
date:  2017-07-21 15:21:16
tags:
- invisible
description: ''
categories:
- 数据结构
---

--- 
## 目录
* [线性表](#1)
* [栈和队列](#2)

---
<h2 id="1"> 线性表	</h2>

**[1]**. 若线性表最常用的操作方式是存取第i个元素及其前驱元素和后继元素的值，为了提高效率，应该采用（ ）的存储方式？  
A. 单链表
B. 双向链表
C. 单循环链表
D. 顺序表

**分析：**  
本题正确答案是D，错选了B。题目明显是需要存储i,i+1,i-1位置元素的值，顺序表可以直接通过下标随机访问到这三个值。时间复杂度为O(1),
而其他所有选项都需要遍历来获取第i个元素的值。时间复杂度为O(n)。  

**[2]**. 实现从有序顺序表中删除其值在给定s和t(s<t)之间的所有元素，如果s,t不合理则显示错误信息并退出运行的算法。

**分析：**  
这题我没有理解清楚题目意思，  
1. 题目给定的是有序表，但是没有说明是升序还是降序。这里应该从两个方面讨论，但是参考答案只给出了升序表的
处理方案，于是认为有序表指的是升序表。
2. 题目给出的s,t区间未说明是开区间(s,t)还是闭区间[s,t]，我理解为闭区间，参考答案上是闭区间[s,t]。

我自己的答案：
```cpp
void DeletRange(SeqData& seq, SeqData min, SeqData max)
{
	if (min >= max)
	{
		puts("Error Info: Min-value > Max-value!");
		//exit(-1);
		return ;
	}

	if (seq.IsEmpty())
	{
		puts("Error Info: Sequence list is empty!");
		//exit(-1);
		return ;
	}

	int len = seq.GetLength();
	int start = -1;
	for (;start<len;start++)
		if (seq.data[start++] > min)
		   break;

    if (start < 0)
    {
    	puts("Error Info: Min-value is too large!");
    	//exit(-1);
		return ;
	}

	int end = start;
	for (; end<len; end++)
		if (seq.data[end] > max)
		   break;

    if (end == len)
    {
		seq.Clear();
		return ;
	}

	for (; end<len; )
		seq.data[start++] = seq.data[end++];

	seq.length -= (max-min-1);
}
```

参考答案如下：
```cpp
bool DeleteRange(SeqList& seq, SeqData min, SeqData max)
{
	int i,j;
	if (min >= max || seq.length == 0)
	   return false;

  //注意这里的for循环内没有执行任何语句
  for (i=0; i<seq.length && seq.data[i]<min; i++) ;

	if (i >= seq.length)
	   return false;

  //注意这里的for循环内没有执行任何语句
  for (j=i; j<seq.length && values[j]<=max; j++) ;

  for (; j<seq.length; i++,j++)
    values[i] = values[j];

  seq.length = i;
  return true;
}
```

参考答案通过bool值来返回操作是否成功，但是并未输出错误信息。个人认为不严谨。两个算法的思路是一样的，时间复杂度也一样，同为O(n)。


【2013年计算机联考题】  
**[3]**. 已知一个整数序列A= (a0,a1,a2,...,a(n-1))，其中0≤ai<n (0≤i<n)。若存在a(p1)=a(p2)=a(p3)=...=a(pm)=x
且m>n/2(0≤pk<n, 1≤k≤m)，则称x为A的主元素。例如A=(0,5,5,3,5,7,5,5)，则5为主元素；又如A=(0,5,5,3,5,1,5,7)，则A中没有主元素。
假设A中的n个元素保存在一个一维数组中，请设计出一个尽可能高效的算法，找出A中的主元素。若存在主元素，则输出该元素；否则输出-1。
要求：  
(1) 给出算法的基本设计思想。  
(2) 根据设计思想，采用C/C++/Java语言描述算法，关键之处给出注释。  
(3) 说明该算法的时间复杂度和空间复杂度。  

我的答案：  
(1) 先对A中所有元素进行排序，然后统计排序后出现次数最多的元素，如果该元素出现次数>m/2则为主元素，否则没有主元素。  
(2)
```cpp
int GetMainElement(int* a, int len)
{
	//先对数组进行排序
	Sort(a,len);

	//mainCount记录主元素出现的次数，currentValue记录当前统计的元素值
	int mainCount=1, currentValue=a[0];

	for (int i=1; i<len; i++)
	{
	    if (a[i] == currentValue)
				mainCount++;
	    else
	    {
	    	currentValue = a[i];	//更换统计的元素值
				mainCount = 1;	//重置主元素个数
			}
	}

	//对主元素出现个数进行判断，大于len/2为主元素，否则没有主元素
	return mainCount > len/2 ? currentValue : -1;
}

void Sort(int *a, int len)
{
	for (int i=0; i<len; i++)
		for (int j=0; j<len-i-1; j++)
			if (a[j] > a[j+1])
			   a[j]^=a[j+1]^=a[j]^=a[j+1]; 	//使用位运算无需中间变量即可更换元素值
}
```
(3) 该算法的时间复杂度为O(n^2)，空间复杂度为O(1)。

**分析：**   
本题满分15分，以上解法只能拿到10分。主要丢分点在于时间复杂度太高，该题最优时间复杂度为O(n)，即使是采用快排也可以将时间复杂度缩小到
O(nlog(2)n) （可以拿到11分），但是不知道考试中是否可以直接调用C++库函数sort。  
因此在平时的积累中，应该对排序算法多加深印象，但是这个分值设定也提醒我，**花费大量时间去思考最优算法是得不偿失的** 。  

参考答案：  
(1):   
算法策略是从前向后扫描数组个数，标记出一个可能成为主元素的元素Num，然后重新计数，确认Num是否为主元素。  
算法可以分为以下两步：  
① 选取候选的元素：依次扫描所给数组中的个整数，将第一个遇到的整数num保存到c中，记录Num的出现次数为1，若遇到的下一个整数仍为num，则计数+1，
否则计数减1，当计数减到0时，将遇到的下一个整数保存到c中，计数重新记为1，开始新一轮计数，即从当前位置开始重复上述过程，直到扫描完全部数组元素。  
② 判断c中元素是否为真正的主元素，再次扫描该数组，统计c中元素出现的个数，若大于n/2则为主元素，否则不存在主元素。  

(2):  
```c
int Majority(int A[], int n)
{
	int i,c,count=1;						//c用来保存候选主元素，count用来计数
	c=A[0];									//设置A[0]为主元素
	for (i=1; i<n; i++)						//查找候选主元素
		if (A[i] == c)
			count++;						//对A中的候选主元素计数
		else
			if (count > 0)					//处理不是候选主元素的情况
				count--;
			else							//更换候选主元素，重新计数
			{
				c = A[i];
				count = 1;
			}
	if (count > 0)
		for (i=count=0; i<n; i++)			//统计候选主元素出现的实际个数
			if (A[i] == c)
				count++;

	if (count > n/2)						//确认候选主元素
		return c;
	else									//不存在候选主元素
		return -1;
}  
```
(3) 算法的时间复杂度为O(n)，空间复杂度为O(1)


**[4]**.设线性表中有2n个元素，（ ）在单链表上实现要比在顺序表中实现效率更高。  
A. 删除所有值为x的元素  
B. 在最后一个元素的后面插入一个新元素  
C. 顺序输出前k个元素  
D. 交换第i个元素和第2n-i-1个元素的值 （i=0, … ,n-1）

**分析：**  
本题正确答案为A，错选了C。我第一次做这个题的时候以为是题目出错了，因为这个选项中，A的时间复杂度是相同的都是O(n)，B和D明显是顺序表更占优势，可以直接排除，所以在AC之间选了一个C。  
其实，对于“效率”这一个词来说，并不能说是单纯的看时间复杂度，因为时间复杂度只是最高的阶数而已，但是除去最高阶，可能还有系数的差别之类的。  
在线性表中删除所有值为x的元素和在但链表中删除所有值为x的元素的确都需要遍历（一般来说，所有出现“所有”字样的操作都需要遍历整个数据结构）来查找，但是，顺序表需要移动大量的元素，而对于单链表的删除操作来说不需要。从这个角度看，线性表在这一操作上效率是要比顺序表高的，故答案为A。  
至于C，两个都一样的，没啥区别。  

**[5]**.给定有n个元素的一维数组，建立一个有序单链表的最低时间复杂度为（ ）。  
A. O(1)  
B. O(n)  
C. O(n^2)  
D. O(nlog(2)n)  

**分析：**  
本题正确答案为D，错选了C。这个题目要求建立一个有序单链表，而数组并没有说是有序，所以除了建立单链表O(n)，时间复杂度主要花费在排序算法上，值得注意的是，**对数组排序的最优算法时间复杂度为O(nlog(2)n)**。所以答案选D。  

**[6]**.在一个长度为n的带头结点的单链表h上，设有尾指针r。则执行（ ）操作与链表的表长有关。  
A. 删除单链表中的第一个元素  
B. 删除单链表中的最后一个元素  
C. 在单链表第一个元素前插入一个新元素  
D. 在单链表最后一个元素后插入一个新元素

**分析：**
本题正确答案选B，错选了D。  
这题没想明白瞎选了一个，其实这个题很简单，只是需要注意一下，这里所说的单链表是纯粹的单链表，不是c++中的vector或是 ~~c++++~~ (C#)中的List，也就是没法只通过结点a找到结点a的前驱结点。  
所以这题就很简单了，A选项，因为带头结点，所以查找第一个元素和表长根本扯不上什么关系。  
B选项，虽然带了一个尾指针，但是这个尾指针只能快速找到最后一个元素，这是要删除最后一个，删除完之后显然尾指针要更新，新的尾巴是谁呢？是原来尾巴的前驱，单链表并没有办法直接找到前驱，只能通过遍历，这又是尾部，所以要遍历完，也就是说表越长，要遍历的越长，和表长有关。  
C和D很明显不涉及到前驱，和表长扯不上关系。  

**[7]**.设计一个递归算法，删除不带头结点的单链表L中所有值为x的结点。  

**分析：**  
这题我不会做。看了答案觉得答案非常巧妙。  
题目要求比较明确，第一要是递归算法，第二链表是不带头结点的单链表。  
说到递归算法，在确定算法之前，一定要明确几点，1是**递归出口**，什么时候返回要明确，不然就会是个死循环。2是**递归主体**，也就是什么时候进入下一层递归。  
这题的递归出口很明显是空表就返回，但是递归主体我没想到。  
~~其实直到2017.7.30我都没有太看懂这段代码…~~  
参考答案如下：  
```cpp
void Del_X_3(LinkList &l, ElemType x)
{
	LNode *p;					//p指向要删除的结点
	if (l == NULL)				//递归出口
		return ;
	
	if (l->data == x)			//若l所指结点的值为x
	{							//删除*l，并让l指向下一结点
		p = l;
		l = l->next;
		free(p);
		Del_X_3(l, x);			//递归调用
	}
	else						//若l所指结点值不为x
		Del_X_3(l->next, x);	//递归调用
}
```
算法需要借助一个递归工作栈，深度为O(n)，时间复杂度为O(n)，这里L是引用，是直接对原链表进行操作，因此free(p)不会断链。  

**[8]**.设L为带头结点的单链表，编写算法实现从尾到头反向输出每个结点的值。

**分析：**  
这题目没有啥要求，只要实现功能就行。这题最简单粗暴的解法是每输出一个值就重新遍历一遍来查找上一次输出结点的前驱输出。但是这样做很不划算，这里给出几种办法，代码就不贴了，给出思路。  
> 1. 先将单链表逆序，然后顺序输出。  
  2. 借助栈，先将链表元素压入栈内，后从栈内依次弹出即为逆序。
  3. 采用递归思想，从后往前输出。  

这里的第3种思路非常独特而巧妙，在这里贴一下代码：  
```cpp
void PrintR(LinkList l)
{
	if (l->next != NULL)
		PrintR(l->next);
	else
		cout<<l->data;
}
```

**[9]**.给定两个单链表，编写算法找出两个链表的公共结点。  

**分析：**  
本题最简单粗暴的办法就是用一个嵌套for循环来查找是否有相同的结点，记链表长度分别为l1,l2，则这样时间复杂度高达O(l1*l2)，只能作为保底方法使用。   
要想高效的解决这个问题最关键的地方在与**如果两个链表有公共结点，因为链表的结点仅有一个后继元素，所以两个链表在公共结点之后的所有结点都是公共的。也就是拓扑结构形如一个Y字形的图示而不可能是X形的图示。同时也即他们的尾结点一定是一样的。**  
题目没有给出两个链表长度相同的条件，所以这两个长度是不确定的。对于长度不相同的两个链表，这种情况很容易想到**尾部对齐**，其实现非常简单：设置两个指针分别指向两个链表的头指针/头结点，指向长度较长的那一个链表的指针先走长度的绝对值差步数后另一个指针才开始移动，这样就保证两个指针一定能同时到达尾部。  
如果对于两个尾部对齐的指针，有在某一步发现两个结点相同，就说明找到了公共结点。  
本题参考答案代码如下：  （代码不重要，重要的是思路）
```cpp
LinkList Search_1st_Common(LinkList L1, LinkList L2)
{
	int len1 = Length(L1), len2 = Length(L2);
	int dist = 0;
	LinkList longList, shortList;

	if (len1 > len2)
	{
		longList = L1->next;
		shortList = L2->next;

		dist = len1-len2;
	}
	else
	{
		longList = L2->next;
		shortList = L1->next;

		dist = len2-len1;
	}

	//尾部对齐
	while(dist--)
		longList = longList->next;

	whlie(longList != NULL)
	{
		if (longList == shortList)
			return longList;
		else
		{
			longList = longList->next;
			shortList = shortList->next;
		}
	}
	
	return NULL;
}
```

[2015年计算机联考试题]  
**[10]**.用单链表保存m个整数，结点的结构为 [data][link]，且|data|≤n（n为正整数）。现要求设计一个时间复杂度尽可能高的算法，对于链表中data的绝对值相等的结点，仅保留第一次出现的结点而删除其余绝对值相等的结点。  
例如给定的单链表如下：  
head-> 21 -> 15 -> -15 -> -7 -> 15 ->NULL  
则删除结点后的链表如下：  
head-> 21 -> 15 -> -7 -> NULL  
要求：  
1）给出算法的基本设计思想。  
2）使用c/c++语言，给出单链表结点的数据类型定义。  
3）根据设计思想，采用c/c++语言描述算法，关键之处给出注释。  
4）说明你所设计的算法的时间复杂度和空间复杂度。  

**分析：**  
本题题干没有要求“尽可能高效的空间复杂度”说明本题如果要达到最优时间复杂度O(n)可能需要借助辅助空间（因为题目要求删除**所有**绝对值相同的点，所以时间复杂度最优为O(n)）。  
这样的话，很容易想到使用一个数组来记录结点中出现过的数的绝对值，这样只需要扫描一次链表就可以完成操作。  

参考答案：  
1）算法的基本设计思想：核心思想是用空间换时间。使用辅助数组记录链表中已出现的数值，从而只对链表进行一躺扫描。  
因为|data|≤n，故辅助数组q的大小为n+1，各元素的初值为0。依次扫描链表中的结点，同时检查q[|data|]的值，如果为0，则保留该结点，并令q[|data|]=1；否则删除该结点。  
2）使用C语言描述的单链表结点的数据类型定义  
```c
typedef struct node
{
	int data;
	struct node *link;
}NODE, *PNODE;
```
3）算法实现  
```c
void func (PNODE h, int n)
{
	PNODE p=h,r;
	int *q,m;
	q= (int*)malloc(sizeof(int)*(n+1));	//申请n+1个位置的辅助空间
	for (int i=0; i< n+1; i++)			//数组元素初值为0
		*(q+1)=0;
	while(p->link != NULL)
	{
		m=p->link->data > 0 ? p->link->data : -p->link->data;
		if (*(q+m)==0)			//判断该结点的data是否已出现过
		{				
			*(q+m)=1;			//首次出现
			p=p->link;			//保留
		}
		else
		{
			r=p->link;			//重复出现
			p->link = r->link;		//删除
			free(r);
		}
	}

	free(q);
}
```
4）时间复杂度和空间复杂度均为O(n)。

 <a href="#">返回本文目录</a>

--- 
<h2 id="2">栈和队列</h2>

**[11]**.设链表不带头结点且所有操作均在表头进行，则下列最不合适作为链栈的是（ ）。  
A. 只有表头结点指针，没有表尾结点指针的双向循环链表。  
B. 只有表尾结点指针，没有表头结点指针的双向循环链表。  
C. 只有表头结点指针，没有表尾节点指针的单向循环链表。  
D. 只有表尾节点指针，没有表头结点指针的单向循环链表。  

**分析：**  
本题正确答案为C，错选了D。  
这题我是秒做的，首先排除了A和B，因为作为一个双向循环链表，随便怎么删头和尾巴都能很容易恢复成双向循环链表。  
而C和D中我选了D，因为我第一反应是对于一个单向循环链表来说，如果删除了表尾结点，要恢复成循环链表需要去找到新的表尾是一件比较麻烦的事情，其实不然，对于一个没有表尾的单向循环链表作为链栈。 **根本就不会去删除表尾啊！** 一个栈只对头进行操作啊！  
下次做题一定要仔细，不能逞英雄，何况自己现在真的渣渣。


 <a href="#">返回本文目录</a>

--- 
<center>  
 <a href="../entranceExamSummary">返回复习目录</a>
</center>
