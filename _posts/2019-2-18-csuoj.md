---
layout: post
title: "CSU OJ解题报告"
image: ''
date:  2019-02-18 00:00:00
tags:
- 算法
description: ''
categories:
- 学习总结
---

--- 
## 前言
本文是本人对即将参加的中南大学2019计算机考研复试上机考试的练习题解题报告汇总，绝大部分题目来自于<a href="http://acm.csu.edu.cn:20080/csuoj/problemset" target="_blank">CSU-ACM Online Judge</a>，提交语言均为C++。

--- 
## 目录
* [1000 - 1002: a+b问题](#1)
* [1003: UC Browser](#2)
* [1005: Binary Search Tree analog](#3)

--- 
## 正文
<h4 id="1">1000 - 1002: a+b问题</h4>

题目链接：<a href="http://acm.csu.edu.cn:20080/csuoj/problemset/problem?pid=1000" target="_blank">1000: A+B (I)</a>，<a href="http://acm.csu.edu.cn:20080/csuoj/problemset/problem?pid=1001" target="_blank">1001: A+B (II)</a>，<a href="http://acm.csu.edu.cn:20080/csuoj/problemset/problem?pid=1002" target="_blank">1002: A+B (III)</a>

 这三道题都是a+b的问题，均为非常基础的OJ题，考试中理应不会出现这样初级的题目，解这几道题目的目的是用于测试本OJ网站的一些特点（如对数据格式精度要求等）。  
 1000与1001基本可以说是同一道题，均为简单实数求和，看清题目要求与格式要求应该可以一遍AC。但是在提交1001时发现题目规定的数字范围仅在[0,1000000]之间，理论上来说使用float就可以满足要求。但是实际测试发现float会导致WA，而使用双精度double时成功AC。  
 AC代码如下：
 ```cpp
1000:
#include <iostream>
#include <cstdio>
using namespace std;

int main(int argc, char** argv)
{
	int a=0, b=0;
	while (scanf("%d%d",&a, &b) != EOF)
	{ cout<<a+b<<endl; }
	
	return 0;
}

1001:
#include <iostream>
#include <cstdio>
using namespace std;

int main(int argc, char** argv)
{
	double a=0.0, b=0.0;
	while (scanf("%lf%lf", &a, &b) != EOF)
	{ printf("%.4lf\n", a+b); }
	
	return 0;
}
 ```

 需要提一点的是1002题，我第一眼看到这个题目就想到了大一时刷到的<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1002" target="_blank">杭电1002题</a>。以为是一道非字符串处理不可的题，但是我在使用字符串模拟算术之前先用long long精度测试了一下发现直接AC了。故这题数据可能出的不太好或者是本意就是long long可以过的题。对字符串处理加法有兴趣的朋友可以移步杭电1002题讨论区。本文仅给出CSU可以AC的代码。 
 ```cpp
 1002:
#include <iostream>
#include <cstdio>
using namespace std;

int main(int argc, char** argv)
{
	long long a=0, b=0;
	while (cin>>a>>b)
	{
		if (!a && !b) return 0;
	 	cout<<a+b<<endl; 
    }
    
	return 0;
}
```
<h4 id="2">1003: UC Browser</h4>
题目链接：<a href="http://acm.csu.edu.cn:20080/csuoj/problemset/problem?pid=1003" target="_blank">1003: UC Browser</a>  

题目大意为给定一个只包含01的字符串，按照1出现的次数来计算结果值，连续的1出现时会影响最终结果，其规律为1个1为10分，2个1为10+20=30分，一直到5个1为10+20+30+40+50=150分，循环节为5，也就是当6个1连续时前5个可以算连续分，第6个数字开始重新计算分数，以此循环。  
代码写起来也没有什么大问题。首先注意一下格式，算法主体是对01字符串进行分析，为此可以直接设置一个标记位记录连续出现的1的个数。遇0则更新分数。  
然后将单个循环节打成数组分数表方便计算，这样很快就能算出总分，然后换算为相应等级即可。  
有部分提交者可能会单独写一个分数转等级的函数，使用一堆if-else来计算，但是观察等级与分数表格发现规律还是很明显的可以通过一行代码计算出来，这样可以简化代码使得看起来更加清晰。  
代码如下:
```cpp
#include <iostream>
#include <cstdio>
using namespace std;

int main(int argc, char** argv)
{
	int count=0, days=0;
	int map[] = {0, 10, 30, 60, 100, 150};  //分数表
	string record="";
	
	cin>>count;
	while (count--)
	{		
		cin>>days>>record;
		int sum=0, ctn=0;
		for(int i=0; i<record.length(); i++)
		{
			if (record[i]=='0') //遇0则刷新一遍分数
			{
				int t = ctn/5;  //t为循环总次数，单次总分数为150
				sum += t*150+map[ctn%5];
				ctn = 0;    //记得重置标记
			}
			else if (record[i]=='1')
				ctn++;  //更新标记
	    }
	    sum+=map[ctn];  //不加此行代码如果最后一位是1则会漏掉一部分分数
	    cout<<(sum-50)/100+1<<endl; //将分数转为等级输出
	}
	
	return 0;
}

```

<h4 id="3">1005: Binary Search Tree analog</h4>
题目链接：<a href="http://acm.csu.edu.cn:20080/csuoj/problemset/problem?pid=1005" target="_blank">1005: Binary Search Tree analog</a> 

本题题干很长，但是基本都是废话，题目的意思就是通过序列创建二叉搜索树并输入先中后序列，属于基础知识题，主要算法是二叉搜索树的插入与二叉树的遍历算法。  
值得注意的一点是本题对格式要求非常低，杭电常见的最后一个空白字符PE在CSUOJ竟然可以直接AC。下面的AC代码在每个遍历序列后都会多输出一个空格，如果对格式要求严格建议使用输出流进行格式控制。  
```cpp
#include <iostream>
#include <cstdio>
using namespace std;

//二叉树数据结构表示
typedef struct node
{
	int data;
	struct node *lchild, *rchild;
}btreenode, *pbtreenode, *btree;

//二叉搜索树的插入函数
btree insert(btree t, pbtreenode node)
{
	pbtreenode tmp = t, prev=NULL;
	while (tmp) //先找到插入位置并记录其父节点
	{
		prev = tmp;
		tmp = node->data < tmp->data ? tmp->lchild : tmp->rchild;
	}
	
	if (!t) t = node;   //依情况进行插入
	else if (prev->data > node->data)
		 prev->lchild = node; 
    else prev->rchild = node;
	
	return t;
}

//先序遍历（递归调用）
void preorder(btree t)
{
	if (t)
	{
		cout<<t->data<<" ";
		preorder(t->lchild);
		preorder(t->rchild);		
	}
}

//中序遍历（递归调用）
void inorder(btree t)
{
	if (t)
	{		
		inorder(t->lchild);
		cout<<t->data<<" ";
		inorder(t->rchild);		
	}
}

//后序遍历（递归调用）
void postorder(btree t)
{
	if (t)
	{		
		postorder(t->lchild);		
		postorder(t->rchild);
		cout<<t->data<<" ";
	}
}

int main(int argc, char** argv)
{
	int count=0;
	btree t=NULL;
	
	cin>>count;
	while (count--)
	{
		int nodecount=0;
		cin>>nodecount;
		while (nodecount--)
		{
			pbtreenode node = (pbtreenode)new btreenode;
			cin>>node->data;
			node->lchild = NULL; node->rchild = NULL;
			t = insert(t, node);
		}
		
		preorder(t); cout<<endl;
		inorder(t); cout<<endl;
		postorder(t); cout<<endl;
	}

	return 0;
}

```




---