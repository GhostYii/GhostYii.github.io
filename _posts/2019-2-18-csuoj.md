---
layout: post
title: "CSU OJ解题报告"
image: ''
date:  2019-02-18 00:00:00
tags:
- 算法
description: ''
categories:
- 学习总结
---

--- 
## 前言
本文是本人对即将参加的中南大学2019计算机考研复试上机考试的练习题解题报告汇总，绝大部分题目来自于中南历年机试原题，小部分来自<a href="http://acm.csu.edu.cn:20080/csuoj/problemset" target="_blank">CSU-ACM Online Judge</a>，提交语言均为C++。

--- 
## 目录
* [1000 - 1002: a+b问题](#1)
* [1003: UC Browser](#2)
* [1005: Binary Search Tree analog](#3)
* [PIPIOJ-1026: a+b问题（中南大学2018机试原题）](#4)
* [DengDengOJ-1009: 切木棍（中南大学2017机试原题）](#5)
* [PIPIOJ-1000: 回文串问题（中南大学2013机试原题）](#6)
* [PIPIOJ-1001: 水仙花数（中南大学2013机试原题）](#7)

--- 
## 正文
<h4 id="1">1000 - 1002: a+b问题</h4>

题目链接：<a href="http://acm.csu.edu.cn:20080/csuoj/problemset/problem?pid=1000" target="_blank">1000: A+B (I)</a>，<a href="http://acm.csu.edu.cn:20080/csuoj/problemset/problem?pid=1001" target="_blank">1001: A+B (II)</a>，<a href="http://acm.csu.edu.cn:20080/csuoj/problemset/problem?pid=1002" target="_blank">1002: A+B (III)</a>

 这三道题都是a+b的问题，均为非常基础的OJ题，考试中理应不会出现这样初级的题目，解这几道题目的目的是用于测试本OJ网站的一些特点（如对数据格式精度要求等）。  
 1000与1001基本可以说是同一道题，均为简单实数求和，看清题目要求与格式要求应该可以一遍AC。但是在提交1001时发现题目规定的数字范围仅在[0,1000000]之间，理论上来说使用float就可以满足要求。但是实际测试发现float会导致WA，而使用双精度double时成功AC。  
 AC代码如下：
 ```cpp
1000:
#include <iostream>
#include <cstdio>
using namespace std;

int main(int argc, char** argv)
{
	int a=0, b=0;
	while (scanf("%d%d",&a, &b) != EOF)
	{ cout<<a+b<<endl; }
	
	return 0;
}

1001:
#include <iostream>
#include <cstdio>
using namespace std;

int main(int argc, char** argv)
{
	double a=0.0, b=0.0;
	while (scanf("%lf%lf", &a, &b) != EOF)
	{ printf("%.4lf\n", a+b); }
	
	return 0;
}
 ```

 需要提一点的是1002题，我第一眼看到这个题目就想到了大一时刷到的<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1002" target="_blank">杭电1002题</a>。以为是一道非字符串处理不可的题，但是我在使用字符串模拟算术之前先用long long精度测试了一下发现直接AC了。故这题数据可能出的不太好或者是本意就是long long可以过的题。对字符串处理加法有兴趣的朋友可以移步杭电1002题讨论区。本文仅给出CSU可以AC的代码。 
 ```cpp
 1002:
#include <iostream>
#include <cstdio>
using namespace std;

int main(int argc, char** argv)
{
	long long a=0, b=0;
	while (cin>>a>>b)
	{
		if (!a && !b) return 0;
	 	cout<<a+b<<endl; 
    }
    
	return 0;
}
```
<h4 id="2">1003: UC Browser</h4>
题目链接：<a href="http://acm.csu.edu.cn:20080/csuoj/problemset/problem?pid=1003" target="_blank">1003: UC Browser</a>  

题目大意为给定一个只包含01的字符串，按照1出现的次数来计算结果值，连续的1出现时会影响最终结果，其规律为1个1为10分，2个1为10+20=30分，一直到5个1为10+20+30+40+50=150分，循环节为5，也就是当6个1连续时前5个可以算连续分，第6个数字开始重新计算分数，以此循环。  
代码写起来也没有什么大问题。首先注意一下格式，算法主体是对01字符串进行分析，为此可以直接设置一个标记位记录连续出现的1的个数。遇0则更新分数。  
然后将单个循环节打成数组分数表方便计算，这样很快就能算出总分，然后换算为相应等级即可。  
有部分提交者可能会单独写一个分数转等级的函数，使用一堆if-else来计算，但是观察等级与分数表格发现规律还是很明显的可以通过一行代码计算出来，这样可以简化代码使得看起来更加清晰。  
代码如下:
```cpp
#include <iostream>
#include <cstdio>
using namespace std;

int main(int argc, char** argv)
{
	int count=0, days=0;
	int map[] = {0, 10, 30, 60, 100, 150};  //分数表
	string record="";
	
	cin>>count;
	while (count--)
	{		
		cin>>days>>record;
		int sum=0, ctn=0;
		for(int i=0; i<record.length(); i++)
		{
			if (record[i]=='0') //遇0则刷新一遍分数
			{
				int t = ctn/5;  //t为循环总次数，单次总分数为150
				sum += t*150+map[ctn%5];
				ctn = 0;    //记得重置标记
			}
			else if (record[i]=='1')
				ctn++;  //更新标记
	    }
	    sum+=map[ctn];  //不加此行代码如果最后一位是1则会漏掉一部分分数
	    cout<<(sum-50)/100+1<<endl; //将分数转为等级输出
	}
	
	return 0;
}

```

<h4 id="3">1005: Binary Search Tree analog</h4>
题目链接：<a href="http://acm.csu.edu.cn:20080/csuoj/problemset/problem?pid=1005" target="_blank">1005: Binary Search Tree analog</a> 

本题题干很长，但是基本都是废话，题目的意思就是通过序列创建二叉搜索树并输入先中后序列，属于基础知识题，主要算法是二叉搜索树的插入与二叉树的遍历算法。  
值得注意的一点是本题对格式要求非常低，杭电常见的最后一个空白字符PE在CSUOJ竟然可以直接AC。下面的AC代码在每个遍历序列后都会多输出一个空格，如果对格式要求严格建议使用输出流进行格式控制。  
```cpp
#include <iostream>
#include <cstdio>
using namespace std;

//二叉树数据结构表示
typedef struct node
{
	int data;
	struct node *lchild, *rchild;
}btreenode, *pbtreenode, *btree;

//二叉搜索树的插入函数
btree insert(btree t, pbtreenode node)
{
	pbtreenode tmp = t, prev=NULL;
	while (tmp) //先找到插入位置并记录其父节点
	{
		prev = tmp;
		tmp = node->data < tmp->data ? tmp->lchild : tmp->rchild;
	}
	
	if (!t) t = node;   //依情况进行插入
	else if (prev->data > node->data)
		 prev->lchild = node; 
    else prev->rchild = node;
	
	return t;
}

//先序遍历（递归调用）
void preorder(btree t)
{
	if (t)
	{
		cout<<t->data<<" ";
		preorder(t->lchild);
		preorder(t->rchild);		
	}
}

//中序遍历（递归调用）
void inorder(btree t)
{
	if (t)
	{		
		inorder(t->lchild);
		cout<<t->data<<" ";
		inorder(t->rchild);		
	}
}

//后序遍历（递归调用）
void postorder(btree t)
{
	if (t)
	{		
		postorder(t->lchild);		
		postorder(t->rchild);
		cout<<t->data<<" ";
	}
}

int main(int argc, char** argv)
{
	int count=0;
	btree t=NULL;
	
	cin>>count;
	while (count--)
	{
		int nodecount=0;
		cin>>nodecount;
		while (nodecount--)
		{
			pbtreenode node = (pbtreenode)new btreenode;
			cin>>node->data;
			node->lchild = NULL; node->rchild = NULL;
			t = insert(t, node);
		}
		
		preorder(t); cout<<endl;
		inorder(t); cout<<endl;
		postorder(t); cout<<endl;
	}

	return 0;
}

```
<h4 id="4">PIPIOJ-1026: a+b问题（中南大学2018机试原题）</h4>

题目链接：<a href="http://39.106.164.46/problem.php?id=1026" target="_blank">1026: a+b问题</a>

这题只是一道简单的A+B问题，由于我很久没有使用过C++语言了，在面对C++的字符串处理上花了一点时间才搞明白字符串分割，结果这道题我写的字符串分割函数提交上去竟然直接返回运行错误的结果。但是下面的代码在本地运行是没有问题的，现在不知道中南的判题机与这个OJ上的是否是同一个。

```cpp
#include <iostream>
#include <vector>
#include <map>
#include <cstdio>
#include <cstring>
#include <cmath>
using namespace std;

#define EXITCODE "zero + zero ="

//字符串分割函数
vector<string> split(const string &str, const string &pattern)
{
    char * strc = new char[strlen(str.c_str())+1];
    strcpy(strc, str.c_str());
    vector<string> res;
    char* temp = strtok(strc, pattern.c_str());
    while(temp != NULL)
    {
        res.push_back(string(temp));
        temp = strtok(NULL, pattern.c_str());
    }
    delete[] strc;
    return res;
}

//英文与数字的对应使用map打成一个表会很方便
map<string, int> getmap()
{
	map<string, int> res;
	res["zero"]=0; res["one"]=1; res["two"]=2;
	res["three"]=3;	res["four"]=4; res["five"]=5;
	res["six"]=6; res["seven"]=7; res["eight"]=8;
	res["nine"]=9;
	return res;
}

int main(int argc, char** argv)
{
	map<string, int> dic = getmap();
	while (true)
	{
		string cmd;
		getline(cin, cmd);
		if (cmd == EXITCODE)
			return 0;

		vector<string> params = split(cmd, "=");
		vector<string> numbers = split(params[0], "+");

		vector<string> numa = split(numbers[0], " ");
		vector<string> numb = split(numbers[1], " ");
		int a=0, b=0, lena=numa.size(), lenb=numb.size();

		for (int i=0, k=lena-1; i<lena; i++)
			a += pow(10, k--)*dic[numa[i]];
		for (int i=0, k=lenb-1; i<lenb; i++)
			b += pow(10, k--)*dic[numb[i]];

		cout<<a+b<<endl;
	}
		
	return 0;
}

```
<h4 id="5">DengDengOJ-1009: 切木棍（中南大学2017机试原题）</h4>

题目链接：<a href="http://acm.csu.edu.cn:20080/csuoj/problemset/problem?pid=1000" target="_blank">1009: 切木棍</a>  

这道题乍一看非常简单，但是我却提交了四次才过。而且在DengDengOJ上AC的代码在PIPIOJ上却出现TLE错误。  
下面给出我在登登OJ上AC的代码，我用了一个比较绕的代码解决了这个问题。其实可以在n为奇数时直接输出0的。  
```cpp
#include <iostream>
#include <cstdio>
using namespace std;

bool isint(double num)
{ return (int)(num/1.0) == num && num!=0; }

int main(int argc, char** argv)
{
	int n;
	while(cin>>n)
	{
		double y=0.0;
		int x=1, count=0;
		
		while (true)
		{	
			if (x > n/4) break;
						
			y = (n/1.0-2*x/1.0)/2.0;
			if (!isint(y) || y<=0)
			{ x++; continue; }
			else
			{ int yy = (int)y; if (x != yy) count++; }
			
			x++;
		}
		cout<<count<<endl;
	}
	return 0;

}

```
<h4 id="6">1000: 回文串问题</h4>

题目链接：<a href="http://acm.csu.edu.cn:20080/csuoj/problemset/problem?pid=1000" target="_blank">1000: 回文串问题</a>

2013年的远古水题，没什么可说的。
```cpp
#include <iostream>
#include <cstdio>
using namespace std;

int main(int argc, char** argv)
{
	string str;
	int count=0;
	while (cin>>str)
	{
		int flag=0;
		for (int i=0; i<str.length()/2; i++)
		{
			if (str[i] == str[str.length()-i-1])
			   flag++;	   
		}
		string res = flag==str.length()/2 ? "yes" : "no";
		cout<<"case"<<++count<<": "<<res<<endl;
	}
	return 0;
}

```
<h4 id="7">1001: 水仙花数</h4>

题目链接：<a href="http://acm.csu.edu.cn:20080/csuoj/problemset/problem?pid=1000" target="_blank">1001: 水仙花数</a>

同上题，远古水题，上C语言课程课堂示例难度。
```cpp
#include <iostream>
#include <cmath>
#include <vector>
using namespace std;

int main(int argc, char** argv)
{
	int s=0, e=0;
	vector<int> res;
	while (cin>>s>>e)
	{
		for (int i=s; i<=e; i++)
		{
		 	int a=i/100, b=i/10%10, c=i%10;	
			if (pow(a,3)+pow(b,3)+pow(c,3)==i)
			   res.push_back(i);
		}
		if (res.size() > 0)
		{
			for (int i=0; i<res.size()-1; i++)
				cout<<res[i]<<" ";
			cout<<res[res.size()-1]<<endl;
		}
		else cout<<"no\n";
								
	}
	return 0;
}

```

---