I""<hr />
<h2 id="1">引言</h2>
<p>在Unity中内置了许多自带的Collider，这些Collider已经可以满足游戏开发中的绝大部分需求。本文介绍一种四棱锥碰撞体生成方案，可生成不同形状的四棱锥碰撞体。</p>

<p><img src="../assets/img/QuaPrism/internal_collider.png" alt="colliders.png" /></p>
<center>内置碰撞体</center>
<p>使用本文方法生成的四棱锥碰撞体如图所示：
<img src="../assets/img/QuaPrism/quaprism.png" alt="qua_prism collider.png" /></p>

<h2 id="2">生成原理</h2>
<p>生成该碰撞体的主要原理是动态生成一个四棱锥的网格，然后使用该网格产生Mesh Collider以实现效果。</p>

<h2 id="3">创建Collider</h2>
<p>在创建Collider之前，需要先产生Mesh。那么，一个四棱锥的Mesh如何产生呢？<br />
回顾一下在Unity中，如何创建一个Mesh，其主要步骤如下：</p>
<ul>
  <li>确定顶点数</li>
  <li>确定三角面/四角面</li>
  <li>确定UV</li>
  <li>计算法线</li>
  <li>计算包围盒</li>
</ul>

<p>对于一个用于产生Mesh Collider的四棱锥而言，uv这一步可以跳过。<br />
四棱锥的顶点数是确定的5个，包括底部矩形的四个顶点和距离矩形一定高度的一个顶点。三角面则是由这5个顶点组成的4个侧边三角面和2个组成底部矩形的三角面构成。
如果我们定义Unity中一个物体的自身位置为四棱锥的上方顶点位置，以该物体自身坐标轴的前方（z轴正方向）maxDistance距离确定一个大小为size的底边矩形，则这5个顶点的位置可以通过以下代码计算：</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Vector3</span> <span class="n">top</span> <span class="p">=</span> <span class="n">transform</span><span class="p">.</span><span class="n">position</span><span class="p">;</span>
<span class="n">Vector3</span> <span class="n">leftUpper</span> <span class="p">=</span> <span class="n">transform</span><span class="p">.</span><span class="n">position</span> <span class="p">+</span> <span class="p">(</span><span class="n">transform</span><span class="p">.</span><span class="n">rotation</span> <span class="p">*</span> <span class="n">luVec</span> <span class="p">*</span> <span class="n">size</span><span class="p">.</span><span class="n">x</span> <span class="p">/</span> <span class="m">2f</span> <span class="p">+</span> <span class="n">transform</span><span class="p">.</span><span class="n">forward</span> <span class="p">*</span> <span class="n">maxDistance</span><span class="p">);</span>
<span class="n">Vector3</span> <span class="n">rightUpper</span> <span class="p">=</span> <span class="n">transform</span><span class="p">.</span><span class="n">position</span> <span class="p">+</span> <span class="p">(</span><span class="n">transform</span><span class="p">.</span><span class="n">rotation</span> <span class="p">*</span> <span class="n">ruVec</span> <span class="p">*</span> <span class="n">size</span><span class="p">.</span><span class="n">x</span> <span class="p">/</span> <span class="m">2f</span> <span class="p">+</span> <span class="n">transform</span><span class="p">.</span><span class="n">forward</span> <span class="p">*</span> <span class="n">maxDistance</span><span class="p">);</span>
<span class="n">Vector3</span> <span class="n">leftLower</span> <span class="p">=</span> <span class="n">transform</span><span class="p">.</span><span class="n">position</span> <span class="p">+</span> <span class="p">(</span><span class="n">transform</span><span class="p">.</span><span class="n">rotation</span> <span class="p">*</span> <span class="n">llVec</span> <span class="p">*</span> <span class="n">size</span><span class="p">.</span><span class="n">y</span> <span class="p">/</span> <span class="m">2f</span> <span class="p">+</span> <span class="n">transform</span><span class="p">.</span><span class="n">forward</span> <span class="p">*</span> <span class="n">maxDistance</span><span class="p">);</span>
<span class="n">Vector3</span> <span class="n">rightLower</span> <span class="p">=</span> <span class="n">transform</span><span class="p">.</span><span class="n">position</span> <span class="p">+</span> <span class="p">(</span><span class="n">transform</span><span class="p">.</span><span class="n">rotation</span> <span class="p">*</span> <span class="n">rlVec</span> <span class="p">*</span> <span class="n">size</span><span class="p">.</span><span class="n">y</span> <span class="p">/</span> <span class="m">2f</span> <span class="p">+</span> <span class="n">transform</span><span class="p">.</span><span class="n">forward</span> <span class="p">*</span> <span class="n">maxDistance</span><span class="p">);</span>
</code></pre></div></div>
<p>确定好顶点位置后，需要通过<code class="language-plaintext highlighter-rouge">transform.InverseTransformPoint</code>API将其转为模型自身坐标位置。三角面的确定则更加简单，假设其5个顶点的顺序如以下代码所示：</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mesh</span><span class="p">.</span><span class="n">vertices</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Vector3</span><span class="p">[]</span>
<span class="p">{</span>
    <span class="n">transform</span><span class="p">.</span><span class="nf">InverseTransformPoint</span><span class="p">(</span><span class="n">top</span><span class="p">),</span>               <span class="c1">//ver0</span>
    <span class="n">transform</span><span class="p">.</span><span class="nf">InverseTransformPoint</span><span class="p">(</span><span class="n">leftUpper</span><span class="p">),</span>         <span class="c1">//ver1</span>
    <span class="n">transform</span><span class="p">.</span><span class="nf">InverseTransformPoint</span><span class="p">(</span><span class="n">rightUpper</span><span class="p">),</span>        <span class="c1">//ver2</span>
    <span class="n">transform</span><span class="p">.</span><span class="nf">InverseTransformPoint</span><span class="p">(</span><span class="n">leftLower</span><span class="p">),</span>         <span class="c1">//ver3</span>
    <span class="n">transform</span><span class="p">.</span><span class="nf">InverseTransformPoint</span><span class="p">(</span><span class="n">rightLower</span><span class="p">)</span>         <span class="c1">//ver4</span>
<span class="p">};</span>
</code></pre></div></div>
<p>由于计算机中的面默认是有正反面的（反面不渲染），我们需要通过顺时针顶点位置来确定三角面的法线方向，则其6个三角面可以通过以下代码确定：</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mesh</span><span class="p">.</span><span class="n">triangles</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[]</span>
<span class="p">{</span>
    <span class="m">0</span><span class="p">,</span><span class="m">1</span><span class="p">,</span><span class="m">2</span><span class="p">,</span>
    <span class="m">0</span><span class="p">,</span><span class="m">3</span><span class="p">,</span><span class="m">1</span><span class="p">,</span>
    <span class="m">0</span><span class="p">,</span><span class="m">2</span><span class="p">,</span><span class="m">4</span><span class="p">,</span>
    <span class="m">0</span><span class="p">,</span><span class="m">4</span><span class="p">,</span><span class="m">3</span><span class="p">,</span>
    <span class="m">3</span><span class="p">,</span><span class="m">2</span><span class="p">,</span><span class="m">1</span><span class="p">,</span>
    <span class="m">2</span><span class="p">,</span><span class="m">3</span><span class="p">,</span><span class="m">4</span>
<span class="p">};</span>
</code></pre></div></div>
<p>之后再去计算发现和包围盒之后，其Mesh就算创建完成了，这时如果在脚本中加载Mesh Renderer组件或者在Gizmos中绘制Mesh，可以看出已经绘制出了一个四棱锥。如下图所示：
<img src="../assets/img/QuaPrism/quaprism_rotate.gif" alt="rotate.gif" /></p>

<p>至此，其四棱锥Mesh已经创建完成，之后只需要挂载Mesh Collider组件，勾选convex选项就可以生成一个动态的四棱锥碰撞体了，其碰撞区域可以通过该物体的transform.localScale来调节。</p>

<h2 id="5">附录</h2>
<p>示例脚本<a href="../assets/downloadable/QuadrangularPrismCollider.cs">点击此处下载</a>。</p>

<hr />
:ET