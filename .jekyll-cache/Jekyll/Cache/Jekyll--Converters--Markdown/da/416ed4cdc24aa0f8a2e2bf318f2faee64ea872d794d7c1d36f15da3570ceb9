I"!8<hr />
<h2 id="0x0引言">0x0.引言</h2>
<p>屏幕UI指示箭头，非常常见的游戏UI元素。它是一个动态的，可以帮助玩家在目标脱离屏幕范围时指示出大概方位的UI元素。<br />
它在游戏中可以充当多种功能，如在玩家受到伤害时只是伤害来源位置、如显示任务目标点或游戏资源的位置、如在多人游戏中显示队友的位置等等。下图是游戏COD16的一张截图，此图非常直观的显示出了UI Arrow的作用。　　
<img src="../assets/img/UIArrow/0.png" alt="ui arrow exam" /><br />
本文将讲述如何在Unity中实现UI指向箭头的效果。</p>

<h2 id="0x1基础思路">0x1.基础思路</h2>
<p>我们希望指示箭头会一直显示在屏幕中，如果目标物体出现在屏幕中时，指示箭头会显示在目标物体的屏幕坐标位置，而目标物体离开屏幕视野时，指示箭头会在屏幕边缘显示其位置。<br />
那么其对应的基本思路是非常明确且清晰的：将目标物体世界坐标转换为对应的屏幕坐标，然后根据其屏幕坐标限制其的显示位置，若坐标不在UI范围内，则限制其坐标点使其先是在边缘位置。</p>

<h2 id="0x2编码实现">0x2.编码实现</h2>
<p>此处的编码我将会一步一步进行实现直至实现最终效果。</p>
<h3 id="0x20坐标转换">0x2.0.坐标转换</h3>
<p>本文使用2D物体作为演示目标。<br />
Unity的坐标转换是开发者遇到的非常常见的问题，转换坐标只需要关注不同坐标轴的对应原点和坐标轴朝向即可，具体的计算可以通过Unity提供的API实现。<br />
此处用到的转换关系为：2D世界坐标轴-&gt;2D屏幕坐标轴。本文使用的UI为Unity自带的UGUI系统，用到的API为：</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">RectTransformUtility</span><span class="p">.</span><span class="nf">WorldToScreenPoint</span><span class="p">(</span><span class="n">Camera</span> <span class="n">cam</span><span class="p">,</span> <span class="n">Vector3</span> <span class="n">worldPos</span><span class="p">)</span>
</code></pre></div></div>
<p>值得注意的一点是，如果将上述API计算得到的值用于RectTransform的anchoredPosition，则需要将该UI元素的锚点设置为left-bottom。这样做的目的是使得两个坐标轴的原点一致，如果想忽略锚点所带来的影响，则直接把计算得到的值赋值给RectTransform.position即可。</p>

<h3 id="0x21限制范围">0x2.1.限制范围</h3>
<p>目前的效果仅仅只是做出了坐标转换，并没有把UI元素限制在视口范围内。现阶段的效果如下：<br />
<img src="../assets/img/UIArrow/1.gif" alt="preview pre" /><br />
上图中，红色菱形方块代表世界物块，白色圆形物体代表UI指向箭头。从图中可以发现白色UI始终在屏幕坐标中的正确位置，但是当右侧红色物体移动至屏幕外时，白色物体也跟着移动到了屏幕外。这显然不是想要的效果。<br />
下一步的工作就是将UI元素的位置限制在玩家的屏幕内。<br />
由于使用的是UGUI，所以此处的“玩家屏幕范围”应该特指挂载了Canvas组件的RectTransform的大小。故在脚本中需要引用一个canvas组件。<br />
单纯的限制范围实现非常简单，下面的代码演示了如何将一个UI物体限制在某个指定的矩形范围内。</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">private</span> <span class="n">Vector2</span> <span class="nf">GetClampPos</span><span class="p">(</span><span class="n">Vector2</span> <span class="n">pos</span><span class="p">,</span> <span class="n">Rect</span> <span class="n">area</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Vector2</span> <span class="n">safePos</span> <span class="p">=</span> <span class="n">Vector2</span><span class="p">.</span><span class="n">zero</span><span class="p">;</span>
    <span class="n">safePos</span><span class="p">.</span><span class="n">x</span> <span class="p">=</span> <span class="n">Mathf</span><span class="p">.</span><span class="nf">Clamp</span><span class="p">(</span><span class="n">pos</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">area</span><span class="p">.</span><span class="n">xMin</span><span class="p">,</span> <span class="n">area</span><span class="p">.</span><span class="n">xMax</span><span class="p">);</span>
    <span class="n">safePos</span><span class="p">.</span><span class="n">y</span> <span class="p">=</span> <span class="n">Mathf</span><span class="p">.</span><span class="nf">Clamp</span><span class="p">(</span><span class="n">pos</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="n">area</span><span class="p">.</span><span class="n">yMin</span><span class="p">,</span> <span class="n">area</span><span class="p">.</span><span class="n">yMax</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">safePos</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>此处关键信息为Rect结构内的xMin，xMax，yMin，yMax等值的确定。上文提到为了得到范围，我们需要获取到挂载了Canvas组件的RectTransform，那么这些值便可以通过其来确定。<br />
则上述代码中的area参数的确定方法如下：</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">private</span> <span class="n">Rect</span> <span class="nf">CalRectByCanvas</span><span class="p">(</span><span class="n">Canvas</span> <span class="n">c</span><span class="p">,</span> <span class="n">Vector2</span> <span class="n">uiSize</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Rect</span> <span class="n">rect</span> <span class="p">=</span> <span class="n">Rect</span><span class="p">.</span><span class="n">zero</span><span class="p">;</span>
    <span class="n">Vector2</span> <span class="n">area</span> <span class="p">=</span> <span class="n">c</span><span class="p">.</span><span class="n">GetComponent</span><span class="p">&lt;</span><span class="n">RectTransform</span><span class="p">&gt;().</span><span class="n">sizeDelta</span><span class="p">;</span>

    <span class="c1">//减去uiSize的一半是为了防止UI元素一般溢出屏幕</span>
    <span class="n">rect</span><span class="p">.</span><span class="n">xMax</span> <span class="p">=</span> <span class="n">area</span><span class="p">.</span><span class="n">x</span> <span class="p">-</span> <span class="n">uiSize</span><span class="p">.</span><span class="n">x</span> <span class="p">/</span> <span class="m">2</span><span class="p">;</span>
    <span class="n">rect</span><span class="p">.</span><span class="n">yMax</span> <span class="p">=</span> <span class="n">area</span><span class="p">.</span><span class="n">y</span> <span class="p">-</span> <span class="n">uiSize</span><span class="p">.</span><span class="n">y</span> <span class="p">/</span> <span class="m">2</span><span class="p">;</span>
    <span class="n">rect</span><span class="p">.</span><span class="n">xMin</span> <span class="p">=</span> <span class="n">uiSize</span><span class="p">.</span><span class="n">x</span> <span class="p">/</span> <span class="m">2</span><span class="p">;</span>
    <span class="n">rect</span><span class="p">.</span><span class="n">yMin</span> <span class="p">=</span> <span class="n">uiSize</span><span class="p">.</span><span class="n">y</span> <span class="p">/</span> <span class="m">2</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">rect</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>值得注意的一点是，如果UI元素的pivot属性不在中心点（0.5,0.5），则上述代码中的计算也要进行相应的变更使得UI元素不会溢出屏幕。</p>

<h3 id="0x22功能实现">0x2.2.功能实现</h3>
<p>坐标转换与限制范围均实现后，直接将其代码结合起来。最终的实现代码也就下面这一句：</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">rectTrans</span><span class="p">.</span><span class="n">position</span> <span class="p">=</span> <span class="nf">GetClampPos</span><span class="p">(</span><span class="n">RectTransformUtility</span><span class="p">.</span><span class="nf">WorldToScreenPoint</span><span class="p">(</span><span class="n">Camera</span><span class="p">.</span><span class="n">main</span><span class="p">,</span> <span class="n">target</span><span class="p">.</span><span class="n">position</span><span class="p">),</span> <span class="nf">CalRectByCanvas</span><span class="p">(</span><span class="n">canvas</span><span class="p">,</span> <span class="n">rectTrans</span><span class="p">.</span><span class="n">sizeDelta</span><span class="p">));</span>
</code></pre></div></div>
<p>最终实现效果如下： 
<img src="../assets/img/UIArrow/2.gif" alt="show" /><br />
其中最左侧显示为游戏实际效果，中间白色区域为UI限制区域，右侧白色区域为摄像头限制区域。</p>

<h2 id="0x3拓展功能">0x3.拓展功能</h2>
<p>有些UI指示标中会显示一个箭头，且箭头方向会指向物体方向。通过本方式去改造成该效果也非常简单。<br />
下面将其代码改造为仅当物体在视野外时显示UI标，且拥有一个箭头指向。<br />
检测物体是否处于视野外有多种方式，在Unity中，可以通过内置回调函数<code class="language-plaintext highlighter-rouge">void OnBecameVisible()</code>和<code class="language-plaintext highlighter-rouge">void OnBecameInvisible()</code>来检测物体是否处于渲染状态，但是在此处不适合。因为此处控制脚本挂载在UI元素上。第二种方式是使用Renderer类中的isVisible属性判断。很明显，使用后者满足场景需求。<br />
值得注意的一点是，上述两种方式仅当所有scene视图与game视图中的物体均不可见才会返回false。<br />
添加一个指示箭头无非多一步用于计算方向，Unity中，如果需要朝向计算，在3D中可以使用LookAt方法实现，但是在2D情况下，LookAt方法的转向轴并非正确，下面的代码实现了2D情况下的LookAt方法：</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="n">Vector3</span> <span class="nf">LookAt2D</span><span class="p">(</span><span class="n">Transform</span> <span class="k">from</span><span class="p">,</span> <span class="n">Vector3</span> <span class="n">to</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">float</span> <span class="n">dx</span> <span class="p">=</span> <span class="n">to</span><span class="p">.</span><span class="n">x</span> <span class="p">-</span> <span class="k">from</span><span class="p">.</span><span class="n">transform</span><span class="p">.</span><span class="n">position</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">dy</span> <span class="p">=</span> <span class="n">to</span><span class="p">.</span><span class="n">y</span> <span class="p">-</span> <span class="k">from</span><span class="p">.</span><span class="n">transform</span><span class="p">.</span><span class="n">position</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">rotationZ</span> <span class="p">=</span> <span class="n">Mathf</span><span class="p">.</span><span class="nf">Atan2</span><span class="p">(</span><span class="n">dy</span><span class="p">,</span> <span class="n">dx</span><span class="p">)</span> <span class="p">*</span> <span class="m">180</span> <span class="p">/</span> <span class="n">Mathf</span><span class="p">.</span><span class="n">PI</span><span class="p">;</span>
    <span class="n">rotationZ</span> <span class="p">-=</span> <span class="m">90</span><span class="p">;</span>

    <span class="kt">float</span> <span class="n">originRotationZ</span> <span class="p">=</span> <span class="k">from</span><span class="p">.</span><span class="n">eulerAngles</span><span class="p">.</span><span class="n">z</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">addRotationZ</span> <span class="p">=</span> <span class="n">rotationZ</span> <span class="p">-</span> <span class="n">originRotationZ</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">addRotationZ</span> <span class="p">&gt;</span> <span class="m">180</span><span class="p">)</span>        
        <span class="n">addRotationZ</span> <span class="p">-=</span> <span class="m">360</span><span class="p">;</span>

    <span class="k">return</span> <span class="k">new</span> <span class="nf">Vector3</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="k">from</span><span class="p">.</span><span class="n">eulerAngles</span><span class="p">.</span><span class="n">z</span> <span class="p">+</span> <span class="n">addRotationZ</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>将得到的角度赋值给箭头对象的eulerAngles属性后就得到了一个朝向标。效果如下： <br />
<img src="../assets/img/UIArrow/3.gif" alt="arrow" /><br />
值得注意一点是，箭头的图片默认应当是朝向上方，否则会出现旋转错误。如果箭头方向无法默认向上，则需要修改LookAt2D方法中的计算使得计算以箭头朝向为基准。</p>

<h2 id="0x4示例代码">0x4.示例代码</h2>
<p>上述具体脚本可以<a href="../assets/downloadable/UIArrow.cs">点击此处下载</a>。</p>

<h2 id="0x5使用方法">0x5.使用方法</h2>
<p>将脚本挂载在UI元素上，赋值上正确的Target，Canvas和Arrow即可预览效果。</p>

<hr />
:ET